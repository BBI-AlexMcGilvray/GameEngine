#pragma once

#include <array>
#include "Core/Headers/CoreDefs.h"
#include "Core/Geometric/Box.h"

namespace Application
{
namespace Collision
{
    class OctTreeNode
    {
        public:
            void AddItem(std::pair<EntityId, ShapeOrientation<Shape3D>> item); // adds item, to a child if possible (may require the creation of a new child if an appropriate one doesn't exist)
            // If the item would be in multiple children at once, it remains in the parent - only put into child if it fits entirely within in
            // maybe only creating children if multiple children are added (so we don't have one child creating an excessive amount of children)
            //      ex: adding a 'point' could would create children until the box was just that specific point in space - that is not needed

        private:
            std::array<std::unique_ptr<OctTreeNode>, 8> _children;
            Core::Geometric::Box _box;
            Core::Math::Float3 _boxOrigin; // the box that represents this does not rotate, but needs a world position for relevance (maybe use a ShapeOrientation?)
            // the above may not be the most efficient in making use of existing collision-detection logic, maybe want a specific 'AABB' box? maybe there is an intermediary workaround...
            std::vector<std::pair<EntityId, ShapeOrientation<Shape3D>>> _heldItems; // this way we can easily check for collisions and return the affected entity
            // the above would be generated by the colliders that are affected
            // std::vector<itme-id-of-some-kind> _heldItemNames; // used to quickly search for a specific item? idk if needed, we shouldn't be using it in this way
    };

    using OctTree = OctTreeNode;
} // namespace Collision
} // namespace Application