#pragma once

#include <array>
#include <vector>

#include "Core/Headers/CoreDefs.h"
#include "Core/Geometric/Box.h"

#include "Pipeline/Collision/Collision.h"
#include "Pipeline/Collision/ColliderComponent.h"
#include "Pipeline/ECS/DataOriented/EntitySnapshot.h"
#include "Pipeline/ECSSystems/TransformComponents.h"

namespace Application
{
namespace Collision
{

struct OctTreeContent
{
    const ShapeOrientation3D shapeOrientation;

    const EntityId entity; // content lasts a whole frame, can't hold snapshots
};

struct OctTreeNode;
OctTreeNode CreateOctTree(const Core::Math::Float3& totalSize);

class OctTreeNode
{
    friend OctTreeNode CreateOctTree(const Core::Math::Float3& totalSize);

    public:
        OctTreeNode(OctTreeNode&&) = default;
        OctTreeNode& operator=(OctTreeNode&&) = default;

        OctTreeNode() = delete;
        OctTreeNode(const OctTreeNode&) = delete;
        OctTreeNode& operator=(const OctTreeNode&) = delete;

        // These just provide the entities that intersect with the provided shape
        EntitySnapshot FindFirstEntity(const ShapeOrientation3D& shape) const;
        std::vector<EntitySnapshot> FindAllEntities(const ShapeOrientation3D& shape) const;
    
        // to avoid having to repeatedly move stop-gapped content, the most efficient thing to do is to add content in order of descending size (biggest/least likely to be engulfed first)
        // so sort by Box[rotated > non-rotated]->Plane[infinite > finite]->Ray[infinite > finite]->Sphere[radius]->Point[-]
        void AddContent(const OctTreeContent& content); // adds item, to a child if possible (may require the creation of a new child if an appropriate one doesn't exist)
        // If the item would be in multiple children at once, it remains in the parent - only put into child if it fits entirely within in
        // maybe only creating children if multiple children are added (so we don't have one child creating an excessive amount of children)
        //      ex: adding a 'point' could would create children until the box was just that specific point in space - that is not needed

        // Collisions occur between two entities within the tree, nothing else
        std::vector<Collision> AllCollisions() const;

        void ClearTree();

    private:
        // EntitySnapshot is not the lightest thing to create, so create these first
        // Then we can create a map of EntityId->EntitySnapshot for all the entities that are in a collision
        // That way we can re-use the EntitySnapshots and avoid the duplicated effort
        struct IntermediaryCollision
        {
            EntityId entity1;
            EntityId entity2;
        };

        std::array<std::unique_ptr<OctTreeNode>, 8> _children;
        Core::Geometric::ShapeOrientation<Core::Geometric::Box> _this;
        // the above may not be the most efficient in making use of existing collision-detection logic, maybe want a specific 'AABB' box? maybe there is an intermediary workaround...
        std::vector<const OctTreeContent> _content; // this way we can easily check for collisions and return the affected entity
        bool _stopGapped = false; // true only when the FIRST element has been placed into a fresh node (as a means to not drill-down forever)
        // the above would be generated by the colliders that are affected
        // std::vector<item-id-of-some-kind> _heldItemNames; // used to quickly search for a specific item? idk if needed, we shouldn't be using it in this way

        OctTreeNode(const Core::Math::Float3& totalSize);
        OctTreeNode(const Core::Math::Float3& origin, const Core::Geometric::Box box);

        void _CreateChildren();
        bool _ChildrenExist() const { return _children[0] != nullptr; }

        bool _Engulfs(const ShapeOrientation3D& data) const;
        OctTreeNode& _FindContainingNode(const ShapeOrientation3D& shape) const;
        void _InsertContent(const OctTreeContent& data);

        void _FindAllEntities(std::vector<EntitySnapshot>& entities, const ShapeOrientation& shape) const;
        void _InternalEntities(std::vector<EntitySnapshot>& entities, const ShapeOrientation& shape) const;
        void _EntitiesForAllContent(std::vector<EntitySnapshot>& entities) const;

        void _AllCollisions(std::vector<IntermediaryCollision>& collisions) const;
        void _InternalCollisions(std::vector<IntermediaryCollision>& collisions) const;
        void _CollisionsWithChildren(std::vector<IntermediaryCollision>& collisions) const;
        void _CollisionsWithAllContent(std::vector<IntermediaryCollision>& collisions, const OctTreeContent& content) const; // if know the data collides with everything, quickly return all collisions
        void _ChildCollisions(std::vector<IntermediaryCollision>& collisions) const;

        std::vector<Collision> _CreateCollisions(const std::vector<IntermediaryCollision>& intermediaryCollisions) const;
};

using OctTree = OctTreeNode;

OctTree CreateOctTree(const Core::Math::Float3& totalSize)
{
    return OctTree(totalSize);
}
} // namespace Collision
} // namespace Application